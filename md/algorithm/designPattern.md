## 常用的javascript设计模式

> 设计模式太多了，貌似有23种，其实我们在平时的工作中没有必要特意去用什么样的设计模式，或者你在不经意间就已经用了设计模式当中的一种。
本文旨在总结平时相对来说用的比较多的设计模式。

### 什么是设计模式


　　设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。

　　使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。

 

#### 实际情况：

　　 设计模式绝对不是纸上谈兵的知识，光看书就以为自己懂了，那只是井底之蛙之见，设计模式绝对是从实践中来到实践中去的！如果编码经验很少，也不太可能能理解好设计模式，但凡软件设计能力强的人编码功底都是相当扎实的。

　　如果没有能深刻理解面向对象，也不太可能理解好设计模式

## 单体模式：
概念：

　　单体是一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象，如果他可以被实例化，那么他只能被实例化一次。

特点：　

- 可以来划分命名空间，从而清除全局变量所带来的危险。
- 利用分支技术来来封装浏览器之间的差异。
- 可以把代码组织的更为一体，便于阅读和维护。

代码实现：

    
    var Singleton = {
    
        attribute:true,
    
        method1:function(){},
    
    　　 method2:function(){}
    };
    
 

### 应用场景：

　　单体模式在我们平时的应用中用的比较多的，相当于把我们的代码封装在一个起来，只是暴露一个入口，从而避免全部变量的污染。


## 工厂模式:
概念：

　　工厂模式的定义：提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）。

- 创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。

- 创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。

- 工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(也就是相互影响)

分类：

 　 **简单工厂模式** ：使用一个类，通常为单体，来生成实例。

　　**复杂工厂模式** 定义是：将其成员对象的实列化推到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。

 　　父类只对创建过程中的一般性问题进行处理，这些处理会**被子类继承，子类之间是相互独立的**，具体的业务逻辑会放在子类中进行编写。
 
代码实现： 

简单工厂模式：　


    var XMLHttpFactory =function(){};　　　　　　//这是一个简单工厂模式
    　　XMLHttpFactory.createXMLHttp =function(){
    　　　 var XMLHttp = null;
    　　　　if (window.XMLHttpRequest){
    　　　　　　XMLHttp = new XMLHttpRequest()
    　　　 }else if (window.ActiveXObject){
    　　　　　　XMLHttp = new ActiveXObject("Microsoft.XMLHTTP")
    　　　　}
    　　return XMLHttp;
    　　}
    　　//XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。
    　　var AjaxHander =function(){
    　　　　var XMLHttp = XMLHttpFactory.createXMLHttp();
    　　　　...
    　　}
    

### 单例模式概念：

　　单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

 

代码实现：

　   单例的实现有很多种，下面只介绍其中的一种，使用~~闭包方式~~ (IIFE)来实现单例，代码如下：


    var single = (function(){
        var unique;
    
        function getInstance(){
    　　　　// 如果该实例存在，则直接返回，否则就对其实例化
            if( unique === undefined ){
                unique = new Construct();
            }
            return unique;
        }
    
        function Construct(){
            // ... 生成单例的构造函数的代码
        }
    
        return {
            getInstance : getInstance
        }
    })();

     

上面的代码中，unique便是返回对象的引用，而 getInstance便是静态方法获得实例。Construct 便是创建实例的构造函数。
 
可以通过 single.getInstance() 来获取到单例，并且每次调用均获取到同一个单例。这就是 单例模式 所实现的效果。
 

使用场景：

单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器的window对象。在js开发中，单例模式的用途同样非常广泛。

试想一下，当我们单击登录按钮的时候，页面中会出现一个登录框，而这个浮窗是唯一的，无论单击多少次登录按钮，这个浮窗只会被创建一次。因此这个登录浮窗就适合用单例模式。

总结一下它的使用场景：

1. 可以用它来划分命名空间

2. 借助单例模式，可以把代码组织的更为一致，方便阅读与维护
 

## 观察者模式（发布订阅模式）
 

### 概念：

　　定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。

它需要一种高级的抽象策略，以便订阅者能够彼此独立地发生改变，而发行方能够接受任何有消费意向的订阅者。　

### 应用场景：　　

这个模式要先说应用场景，比较好理解。

比如，博客园里面有一个订阅的按钮（貌似有bug），比如小A,小B,小C都订阅了我的博客，当我的博客一有更新时，就会统一发布邮件给他们这三个人，就会通知这些订阅者

#### 发布订阅模式的流程如下：

1. 确定谁是发布者(比如我的博客)。

2. 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者。

3. 发布消息，发布者需要遍历这个缓存列表，依次触发里面存放的订阅者回调函数。

4. 退订（比如不想再接收到这些订阅的信息了，就可以取消掉）