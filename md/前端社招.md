## CSS盒模型
### 一 css盒子模型概念
CSS css盒子模型 又称框模型 (Box Model) ，包含了 元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素
### 二 css 外边距合并（叠加）
两个上下方向相邻的元素框垂直相遇时，外边距会合并，合并后的外边距的高度等于两个发生合并的外边距中较高的那个边距值

需要注意的是：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并
###三、box-sizing属性介绍
box-sizing属性是用户界面属性里的一种，之所以介绍它，是因为这个属性跟盒子模型有关，而且在css reset中有可能会用到它。

box-sizing : content-box|border-box|inherit;

(1) content-box ,默认值，可以使设置的宽度和高度值应用到元素的内容框。盒子的width只包含内容。

　　即总宽度=margin+border+padding+width

(2) border-box , 设置的width值其实是除margin外的border+padding+element的总宽度。盒子的width包含border+padding+内容

　　　　即总宽度=margin+width

很多CSS框架，都会对盒子模型的计算方法进行简化。

(3) inherit , 规定应从父元素继承 box-sizing 属性的值
### 关于border-box的使用(应用场景)：  
> 1 一个box宽度为100%，又想要两边有内间距，这时候用border-box就比较好  
2 全局设置 border-box 很好，首先它符合直觉，其次它可以省去一次又一次的加加减减，它还有一个关键作用——让有边框的盒子正常使用百分比宽度。  
### 四、实际开发中遇到的和框模型相关的应用及小问题。  
#### 1 margin越界（第一个子元素的margin-top和最后一个子元素的margin-bottom的越界问题）

以第一个子元素的margin-top 为例：

当父元素没有边框border时，设置第一个子元素的margin-top值的时候，会出现margin-top值加在父元素上的现象，解决方法有四个：

- 给父元素加边框border （副作用）

- 给父元素设置padding值  （副作用）

- 父元素添加 overflow：hidden （副作用）

- 父元素加前置内容生成。（推荐）

以第四种方法为例：  
```
.parent {
     width : 500px;
     height : 500px;
     background-color : red;       
}
.parent : before {
     content : " ";
     display : table;
}

.child {
     width : 200px;
     height : 200px;
     background-color : green;
     margin-top : 50px;
}

<div class="parent">
    <div class="child"></div> 
</div>

```

#### 2 浏览器间的盒子模型。

（1）ul标签在Mozilla中默认是有padding值的，而在IE中只有margin有值。

（2）标准盒子模型与IE模型之间的差异：

标准的盒子模型就是上述介绍的那种，而IE模型更像是 box-sizing : border-box; 和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border 和 pading。
解决办法就是：在html模板中加doctype声明。

#### 3 用盒子模型画三角形

    <!DOCTYPE html>
    <html>
      <head>
    <style>
    .triangle {
    width : 0;
    height: 0;
    border : 100px solid transparent;
    border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角*/
    }
    </style>
      </head>
      <body>
    <div class="triangle"></div>
      </body>
    </html>


## FLEX布局  

flex（ flexible box：弹性布局盒模型）,是2009年w3c提出的一种可以简洁、快速弹性布局的属性。**主要思想是给予容器控制内部元素高度和宽度的能力。**
采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。

容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。
主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；  
交叉轴的开始位置叫做cross start，结束位置叫做cross end。
项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。


**首先要有个容器，并设置display:flex;display:-webkit-flex;该容器有以下六个属性：**
	
    flex-direction (元素排列方向)  
    	row, row-reverse, column, column-reverse  
    flex-wrap (换行)  
    	nowrap, wrap, wrap-reverse  
    flex-flow (以上两者的简写)  
    	flex-direction || flex-wrap  
    justify-content (水平对齐方式)  
    	flex-start, flex-end, center, space-between, space-around  
    align-items (垂直对齐方式)  
    	stretch, flex-start, flex-end, center, baseline  
    align-content (多行垂直对齐方式)  
    	stretch, flex-start, flex-end, center, space-between, space-around  

整体的layout用grid，某个section用flex
Flex 和 Grid 并不是互斥的技术，相反，它们是互补的。  
Flex 一般用来做 Page Components 的局部布局，而且一般只做一维的布局，比如导航栏。  
Grid 则一般用来做二维平面的布局，通常用于整个页面的规划。这也是这两个技术发明的初衷，它们相辅相成，并行不悖。

## 上下左右垂直居中

**【思路一】： 行高line-height实现单行文本垂直居中**

　　行内流传着一种说法，单行文本垂直居中要将高度和行高设置成相同的值，但高度其实没必要设置。实际上，文本本身就在一行中居中显示。在不设置高度的情况下，行高撑开高度

**【思路二】：设置vertical-align:middle实现垂直居中**

【1】设置父元素的display为table-cell

　　通过为table-cell元素设置vertical-align:middle，可使其子元素均实现垂直居中。这和表格里单元格的垂直居中是类似的

　　[注意]若要IE7-浏览器支持，则可以将其改为<table>表格结构

　　[注意]设置为table-cell的div不能使用浮动或绝对定位，因为浮动或绝对定位会使元素具有块级元素特性，从而丧失了table-cell元素具有的垂直对齐的功能。若需要浮动或绝对定位处理，则需要外面再套一层div

    <style>
    .parent{
      display: table-cell;
      vertical-align: middle;
    }
    </style>
    <div class="parent" style="height: 100px;">
    <div class="child" >我是有点长的有点长的有点长的有点长的测试文字</div>   
    </div>  

**若子元素是图片，通过设置父元素的行高来代替高度，且设置父元素的font-size为0**

vertical-align:middle的解释是元素的中垂点与父元素的基线加1/2父元素中字母X的高度对齐。  
由于字符X在em框中并不是垂直居中的，且各个字体的字符X的高低位置不一致。  
所以，当字体大小较大时，这种差异就更明显。  
当font-size为0时，相当于把字符X的字体大小设置为0，于是可以实现完全的垂直居中

    <style>
    .parent{
      line-height: 100px;
      font-size: 0;
    }
    .child{
      vertical-align: middle;
    }
    </style>

    <div class="parent" style="background-color: lightgray;width:200px;">
    <img class="child" src="http://sandbox.runjs.cn/uploads/rs/26/ddzmgynp/img1.gif" width="50%" alt="test">  
    </div>

**【思路三】：通过绝对定位实现垂直居中**

【1】配合translate()位移函数  
translate函数的百分比是相对于自身高度的，所以top:50%配合translateY(-50%)可实现居中效果  

[注意]IE9-浏览器不支持  

[注意]若子元素的高度已知，translate()函数也可替换为margin-top: 负的高度值

    .parent{
      position:relative;
    }
    .child{
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
    }
    
    <div class="parent">
      <div class="child" >测试文字</div>
    </div>  


**【思路四】：使用弹性盒模型flex实现垂直居中**

【1】在伸缩容器上设置侧轴对齐方式align-items: center

    <style>
    .parent{
      display: flex;
      align-items: center;
    }
    </style>
    <div class="parent" style="height: 100px;">
    <div class="child">测试文字</div>   
    </div>
【2】在伸缩项目上设置margin: auto 0
    
    .parent{
      display: flex;
    }
    .child{
      margin: auto 0;
    }

    <div class="parent" style="height: 100px;">
    <div class="child" >测试文字</div>   
    </div>

**【思路五】: 使用栅格布局grid实现垂直居中**  
【1】在网格容器上设置align-items或align-content

【2】在网格项目中设置align-self或者margin: auto 0

    .parent{
      display:grid;
    } 
    .child{
      align-self:center;
     /*margin: auto 0;*/
    }
    
    <div class="parent" style="background-color: gray; height: 100px;">
    <div class="child" style="background-color: lightblue;">测试文字</div>   
    </div>
----
## 原型链，对象，构造函数之间的一些联系

    function test(){

	}    
    console.log(test.prototype.constructor === test) // true
> 　如上，当我们创建一个函数，系统就会为这个函数自动分配一个prototype指针，指向它的原型对象。  
> 　并且可以发现，这个原型对象包含两个部分（constructor 和 __proto__）其中constructor指向函数自身。（这里形成了一个小闭环）

	function test(){

	}
	var mytest = new test;   
	console.log(mytest.__proto__ === test.prototype) // true

	function test(){

	}
	var mytest = new test; 
	console.log(mytest.__proto__.constructor === test) // true


> 如上,当我们将该函数作为模版创建实例（new方法）的时候，我们发现创建出的实例是一个与构造函数同名的object，这个object是独立的，他只包含了一个__proto__指针（实例没有prototype，强行访问则会输出undefined），这个指针指向上面提到的构造函数的prototype原型对象。  
> 
> 这时候我们发现三者形成了一个大"闭环"。之所以加上引号，因为构造函数和实例之间无法直接访问，需要通过__proto__指针间接读取。

 这个"大闭环"画出来就是下面这个样子啦：


### (2) prototype是啥，__proto__又是啥，他们之间啥关系？
	
在上一个问题中，我们用到了实例对象的__proto__指针，实际上在JavaScript中大部分类型的值都拥有__proto__属性，例如：

    console.log('str'.__proto__)
    String {length: 0, encodeHTML: ƒ, constructor: ƒ, charAt: ƒ, charCodeAt: ƒ, …}
    
    console.log(NaN.__proto__)
    Number {constructor: ƒ, toExponential: ƒ, toFixed: ƒ, toPrecision: ƒ, toString: ƒ, …}
    
    console.log(true.__proto__)
    Boolean {[[PrimitiveValue]]: false, constructor: ƒ, toString: ƒ, valueOf: ƒ}

当然object和function对象也有：

    function test(){} 
    console.log(test.__proto__);
    ƒ () { [native code] }

不过也有不存在__proto___属性的类型，比如：  
**undefined和null**

然而。只有function对象才有prototype属性，其他任何类型的值都没有。即使是使用new方法从function构造出的实例对象也没有prototype属性。

###（3）如果改变一个 constructor 的 prototype，他的实例会发生什么改变？
   
我们来做一个尝试:  

    function OmakeNewCar(){}
    function QmakeNewCar(){}
    var car = new OmakeNewCar;
    
    OmakeNewCar.prototype = function QmakeNewCar(){};
    var truck = new QmakeNewCar;
    
    console.log(truck);
    
    console.log(car);
    VM236:8 QmakeNewCar {}__proto__: constructor: ƒ QmakeNewCar()__proto__: Object
    VM236:10 OmakeNewCar {}__proto__: constructor: ƒ OmakeNewCar()__proto__: Object
    

我们可以发现，改变了prototype之后创建的实例指向了新的prototype对象，而之前的依然指向老的prototype对象。

##DOM事件的绑定的几种方式

    　　1. <div id="btn" onclick="clickone()"></div> //直接在DOM里绑定事件
    
    　　　　<script>
    
    　　　　　function clickone(){ alert("hello"); }
    
    　　　　</script>
    
    　　2. <div id="btn"></div>
    
    　　　　<script>
    
    　　　　　document.getElementById("btn").onclick = function（）{ alert("hello"); } //脚本里面绑定
    
    　　　　</script>
    
    　　3. <div id="btn"></div>
    
    　　　　<script>
    
    　　　　　document.getElementById("btn").addeventlistener("click",clickone,false); //通过侦听事件处理相应的函数
    
    　　　　　function clickone(){ alert("hello"); }
    
    　　　　</script>
    
那么问题来了，1 和 2 的方式是我们经常用到的，那么既然已经有两种绑定事件的方法为什么还要有第三种呢？答案是这样的：

**用 "addeventlistener" 可以绑定多次同一个事件，且都会执行**，而在DOM结构如果绑定两个 "onclick" 事件，只会执行第一个；  

在脚本通过匿名函数的方式绑定的只会执行最后一个事件。

##http2.0,websocket,https  

WebSocket是基于HTTP1.1的协议，可以简单理解为创建了一条TCP连接  
Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说
WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。  
它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的**双向**平等对话，属于服务器推送技术的一种。

在JS中用
    new WebSocket("ws://hostname/chattingrom/")  

HTTP2.0则是对HTML、CSS等JS资源的传输方式进行了优化，并没有提供新的JS API，不能用于实时传输消息。

HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。  
即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

##长连接与长轮询  
**轮询**：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。   
优点：后端程序编写比较容易。 
缺点：请求中有大半是无用，浪费带宽和服务器资源。 
实例：适于小型应用。


**长轮询**：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 
优点：在无消息的情况下不会频繁的请求，耗费资源小。 
缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 
实例：WebQQ、Hi网页版、Facebook IM。

**长连接**：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。 
优点：消息即时到达，不发无用请求；管理起来也相对方便。 
缺点：服务器维护一个长连接会增加开销。 
实例：Gmail聊天

至于怎么在不支持Websocket的客户端上使用Websocket。。答案是：不能  
但是可以通过上面说的 long poll 和 ajax 轮询来 模拟出类似的效果

##webpack配置文件：入口和出口，多入口、多出口配置

    const path = require('path');
    module.exports={
        //入口文件的配置项
    entry:{
    entry:'./src/entry.js'
    },
    //出口文件的配置项
    output:{
    //输出的路径，用了Node语法
    path:path.resolve(__dirname,'dist'),
    //输出的文件名称
    filename:'bundle.js'
    },
    //模块：例如解读CSS,图片如何转换，压缩
    module:{},
    //插件，用于生产模版和各项功能
    plugins:[],
    //配置webpack开发服务功能
    devServer:{}
    }

> entry：配置入口文件的地址，可以是单一入口，也可以是多入口。
> 
> output：配置出口文件的地址，在webpack2.X版本后，支持多出口配置。
> 
> module：配置模块，主要是解析CSS和图片转换压缩等功能。
> 
> plugins：配置插件，根据你的需要配置不同功能的插件。
> 
> devServer：配置开发服务功能。
> 
> 然后在终端输入：webpack    进行打包

###多入口、多出口配置
    const path = require('path');
    module.exports={
    //入口文件的配置项
    entry:{
    entry:'./src/entry.js',
    //这里我们又引入了一个入口文件
    entry2:'./src/entry2.js'
    },
    //出口文件的配置项
    output:{
    //输出的路径，用了Node语法
    path:path.resolve(__dirname,'dist'),
    //输出的文件名称
    filename:'[name].js'
    },
    //模块：例如解读CSS,图片如何转换，压缩
    module:{},
    //插件，用于生产模版和各项功能
    plugins:[],
    //配置webpack开发服务功能
    devServer:{}
    }

> 在入口文件中，新增了一个entry.js的入口文件，这个文件需要手动建立，出口文件的filename，我们把原来的bundle.js修改成了[name].js
> 
> [name]的意思是根据入口文件的名称，打包成相同的名称，有几个入口文件，就可以打包出几个文件。

##HTTP之状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:

1xx：指示信息--表示请求已接收，继续处理

2xx：成功--表示请求已被成功接收、理解、接受

3xx：重定向--要完成请求必须进行更进一步的操作

4xx：客户端错误--请求有语法错误或请求无法实现

5xx：服务器端错误--服务器未能实现合法的请求

常见状态码：

> 200 OK                        //客户端请求成功
> 304	Not Modified 	//未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
> 305	Use Proxy	//使用代理。所请求的资源必须通过代理访问
> 400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
> 401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
> 403 Forbidden                 //服务器收到请求，但是拒绝提供服务
> 404 Not Found                 //请求资源不存在，eg：输入了错误的URL
> 500 Internal Server Error     //服务器发生不可预期的错误
> 503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常

##Babel
Babel是一个转换编译器，它能将ES6转换成可以在浏览器中运行的代码。