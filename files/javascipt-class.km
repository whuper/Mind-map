{"root":{"data":{"id":"biqkilep64w8","created":1516348032413,"text":"javascript的类和继承的实现","expandState":"expand","note":">写在前面\n>一直不喜欢JS的OOP，在学习阶段好像也用不到，总觉得JS的OOP不伦不类的，可能是因为先接触了Java，所以对JS的OO部分有些抵触。\n偏见归偏见，既然面试官问到了JS的OOP，那么说明这东西肯定是有用的，应该抛开偏见，认真地了解一下\n\n\n```\n/*\n * 约定\n */\nfunction Fun(){\n    // 私有属性\n    var val = 1;        // 私有基本属性\n    var arr = [1];      // 私有引用属性\n    function fun(){}    // 私有函数（引用属性）\n \n    // 实例属性\n    this.val = 1;               // 实例基本属性\n    this.arr = [1];             // 实例引用属性\n    this.fun = function(){};    // 实例函数（引用属性）\n}\n \n// 原型属性\nFun.prototype.val = 1;              // 原型基本属性\nFun.prototype.arr = [1];            // 原型引用属性\n\n```\nFun.prototype.fun = function(){};   // 原型函数（引用属性）"},"children":[{"data":{"id":"biqkjur9r94w","created":1516348131129,"text":"原型","layout_mind_offset":{"x":62,"y":43},"note":"```\nfunction Super(){\n    this.val = 1;\n    this.arr = [1];\n}\nfunction Sub(){\n    // ...\n}\nSub.prototype = new Super();    // 核心\n \nvar sub1 = new Sub();\nvar sub2 = new Sub();\nsub1.val = 2;\nsub1.arr.push(2);\nalert(sub1.val);    // 2\nalert(sub2.val);    // 1\n \nalert(sub1.arr);    // 1, 2\nalert(sub2.arr);    // 1, 2\n```\n\n#核心\n拿父类实例来充当子类原型对象\n#优缺点\n##优点：\n简单，易于实现\n##缺点：\n1. 修改sub1.arr后sub2.arr也变了，因为来自原型对象的引用属性是所有实例共享的。\n\n2. 创建子类实例时，无法向父类构造函数传参","expandState":"expand"},"children":[]},{"data":{"id":"biqkjwhim00k","created":1516348134892,"text":"构造函数","layout_mind_offset":{"x":61,"y":58},"note":"```\nfunction Super(val){\n    this.val = val;\n    this.arr = [1];\n \n    this.fun = function(){\n        // ...\n    }\n}\nfunction Sub(val){\n    Super.call(this, val);   // 核心\n    // ...\n}\n \nvar sub1 = new Sub(1);\nvar sub2 = new Sub(2);\nsub1.arr.push(2);\nalert(sub1.val);    // 1\nalert(sub2.val);    // 2\n \nalert(sub1.arr);    // 1, 2\nalert(sub2.arr);    // 1\n \nalert(sub1.fun === sub2.fun);   // false\n```\n\n#核心\n\n借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）\n#优缺点\n\n##优点：\n1. 解决了子类实例共享父类引用属性的问题\n\n2. 创建子类实例时，可以向父类构造函数传参\n\n##缺点：\n无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸","expandState":"expand"},"children":[]},{"data":{"id":"biqkjvm8gdck","created":1516348133001,"text":"原型+构造函数","layout_mind_offset":{"x":564,"y":204},"note":"```\nfunction Super(){\n    // 只在此处声明基本属性和引用属性\n    this.val = 1;\n    this.arr = [1];\n}\n//  在此处声明函数\nSuper.prototype.fun1 = function(){};\nSuper.prototype.fun2 = function(){};\n//Super.prototype.fun3...\nfunction Sub(){\n    Super.call(this);   // 核心\n    // ...\n}\nSub.prototype = new Super();    // 核心\n \nvar sub1 = new Sub(1);\nvar sub2 = new Sub(2);\nalert(sub1.fun === sub2.fun);   // true\n```\n#核心\n\n把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Sub.prototype = new Super();继承父类函数，实现函数复用\n#优缺点\n\n##优点：\n不存在引用属性共享问题\n可传参\n函数可复用\n##缺点:\n（一点小瑕疵）子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的。。。又是内存浪费，比刚才情况好点，不过确实是瑕疵","expandState":"expand"},"children":[]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}