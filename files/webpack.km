{"root":{"data":{"text":"webpack","note":"WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用.\nWebpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。","expandState":"expand"},"children":[{"data":{"id":"bjbty0f3ghcs","created":1518507389631,"text":"Webpack的强大功能","expandState":"expand","layout":null},"children":[{"data":{"id":"bjbty3vg47sc","created":1518507397150,"text":"生成Source Maps（使调试更容易）","layout":null},"children":[]},{"data":{"id":"bjbtyc1rra8g","created":1518507414946,"text":"使用webpack构建本地服务器","note":"想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖","layout":null},"children":[]},{"data":{"id":"bjbu3w3tw2ok","created":1518507850427,"text":"CSS","expandState":"expand","note":"webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中\n","layout":null},"children":[{"data":{"id":"bjbu3yduf4wg","created":1518507855386,"text":"css-loader","layout":null},"children":[]},{"data":{"id":"bjbu45z08wwg","created":1518507871904,"text":"style-loader","expandState":"expand","layout":null},"children":[]},{"data":{"id":"bjbu5xqkbig4","created":1518508010707,"text":"CSS module","note":"CSS modules的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染\n\n","layout":null},"children":[]},{"data":{"id":"bjbu6y8xwe80","created":1518508090182,"text":"CSS预处理器","note":"Sass 和 Less 之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句\n\n常用的CSS 处理loaders:\n\nLess Loader\nSass Loader\nStylus Loader","layout":null},"children":[]}]}]},{"data":{"id":"bjbtyy57qo00","created":1518507463044,"text":"Loaders","note":"Loaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。\n\nLoaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：\n\ntest：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）\nloader：loader的名称（必须）\ninclude/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；\nquery：为loaders提供额外的设置选项（可选）\n","layout":null},"children":[]},{"data":{"id":"bjbtzqf9s4gg","created":1518507524602,"text":"Babel(编译JavaScript)","note":"Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n\n让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；\n让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；\n\nBabel的安装与配置\n\nBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。\n\n","layout":null},"children":[{"data":{"id":"bjbu1bbpgr48","created":1518507648463,"text":"babel的配置","note":"module.exports = {\n    entry: __dirname + \"/app/main.js\",//已多次提及的唯一入口文件\n    output: {\n        path: __dirname + \"/public\",//打包后的文件存放的地方\n        filename: \"bundle.js\"//打包后输出文件的文件名\n    },\n    devtool: 'eval-source-map',\n    devServer: {\n        contentBase: \"./public\",//本地服务器所加载的页面所在的目录\n        historyApiFallback: true,//不跳转\n        inline: true//实时刷新\n    },\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/,\n                use: {\n                    loader: \"babel-loader\",\n                    options: {\n                        presets: [\n                            \"env\", \"react\"\n                        ]\n                    }\n                },\n                exclude: /node_modules/\n            }\n        ]\n    }\n};","layout":null},"children":[]}]},{"data":{"id":"bjbu830d4hs0","created":1518508178912,"text":"插件（Plugins）","note":"插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。\nLoaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。\n\n\nconst webpack = require('webpack');\n\nmodule.exports = {\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/,\n                use: {\n                    loader: \"babel-loader\"\n                },\n                exclude: /node_modules/\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: \"style-loader\"\n                    }, {\n                        loader: \"css-loader\",\n                        options: {\n                            modules: true\n                        }\n                    }, {\n                        loader: \"postcss-loader\"\n                    }\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new webpack.BannerPlugin('版权所有，翻版必究')\n    ],\n};\n","expandState":"expand","layout":null},"children":[{"data":{"id":"bjbubxwh6yw4","created":1518508481250,"text":"常用的插件","layout":null},"children":[{"data":{"id":"bjbuc8lrv484","created":1518508504547,"text":"HtmlWebpackPlugin","note":"这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）。","layout":null},"children":[]},{"data":{"id":"bjbucsl65k8o","created":1518508548046,"text":"Hot Module Replacement","note":"Hot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。\n\n在webpack中实现HMR也很简单，只需要做两项配置\n\n在webpack配置文件中添加HMR插件；\n在Webpack Dev Server中添加“hot”参数；\n不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。\n\n","layout":null},"children":[]},{"data":{"id":"bjbugyb4urs4","created":1518508873957,"text":"优化插件","expandState":"expand","note":"OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID\nUglifyJsPlugin：压缩JS代码；\n\nExtractTextPlugin：分离CSS和JS文件","layout":null},"children":[]}]},{"data":{"id":"bjbujtj1pyos","created":1518509098644,"text":"缓存","note":"缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）\n\nwebpack可以把一个哈希值添加到打包的文件名中\n去除build文件中的残余文件\n\n添加了hash之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，因此这里介绍另外一个很好用的插件\n\nclean-webpack-plugin\n\nconst CleanWebpackPlugin = require(\"clean-webpack-plugin\");\n  plugins: [\n    ...// 这里是之前配置的其它各种插件\n    new CleanWebpackPlugin('build/*.*', {\n      root: __dirname,\n      verbose: true,\n      dry: false\n  })\n  ]\n","layout":null},"children":[]}]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}