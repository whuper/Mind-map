
HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：
## HTTP状态码分类
分类	分类描述

* 1**	信息，服务器收到请求，需要请求者继续执行操作
* 2**	成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误



## 输入url到加载完成发生了什么

一般会经历以下过程：

1.在浏览器中输入url。  
2.浏览器先查看**浏览器缓存--系统缓存--路由器缓存**，如果缓存中存在页面内容，就会直接在屏幕中显示。  
3.在发送http请求前，浏览器开启一个线程来解析域名(**[DNS解析]**，获取相应的IP地址。   
4.浏览器向服务器发起TCP连接，与浏览器通过**TCP三次握手**建立连接；	   
5.握手成功后，浏览器向服务器发送**HTTP请求**，请求数据包。  
6.服务器处理收到的请求，将数据返回给浏览器。   
7.浏览器收到**HTTP响应**。   
8.接下来就是**[页面渲染]**的内容了。

## 三次握手

第一次握手：客户端向服务器发送**SYN**报文，传达信息 “你好，我想建立连接”，客户端进入SYN_SEND状态。                         
第二次握手：服务器返回**SYN+ACK**报文，传达信息 “好的，可以建立连接”，服务器端进入SYN_REC状态。                           
第三次握手：客户端回传 **ACK**报文,传达信息“好的，知道了，那我们连接”，然后就建立连接了。此时客户端和服务器端都进入ESTABLISHED状态。                     

三次握手的机制是为了保证信息传输的可靠性，如果其中某个握手失败了，这个过程将会重复。 
 
- 如果采用两次握手：   
如果发送ACK报文的客户端不想连接了，也没有反馈，而服务器端则一直等待，浪费了时间。
- 如果采用四次握手：    
从结果而言是可以的，但是性能大大受影响，三次是个折中的方案，节省了连接的时间。


## 页面渲染原理

主流的Webkit内核浏览器（Safiri）和Gecko内核浏览器（FireFox）在渲染引擎的具体步骤上有些不同，但是大致的原理如下图：
  
![](http://i.imgur.com/cI1G3m5.jpg)

1. 浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。

2. 浏览器把CSS样式解析成样式解析成样式结构体CSSDOM树，解析过程中去掉浏览器不能识别的样式，比如IE浏览器去掉-moz开头的样式，而FF浏览器去掉_开头的样式等。

3. DOM树和CSSDOM树组合构建渲染树（render tree），此时的render tree和DOM相似，但事实上有很大的区别。render tree能识别样式。render tree里面的每一个节点都有自己的样式，因此，像<head>标签这些不用于渲染的节点，不会被包含于render tree中。render tree中每一个节点都可以称作盒子（Box）。   
值得注意的是，`display: none；` 和 `visible： hidden；`虽然很像，但是前者不会被包含在render tree中，因为它是不占空间而且不可见的，后者虽然不可见，但是占用空间，会影响布局（layout），所以包含在数中。

4. 一旦render tree构建完毕，浏览器就可以根据render tree来绘制页面了。

## post和get
区别：

- post更安全  
因为post的请求数据不会作为url的一部分，不会被缓存、保存在服务器日志、浏览器的浏览记录中。
- post发送的数据量更大  
get有url长度的限制，不能大于2kb。
- post能发送更多的数据类型  
get只能发送ASCII字符
- post比get要慢  
	- post方法在正式接收数据之前会将请求投发送给服务器确认，然后才发送数据，这个确认过程花费较长的时间。
	- get方法会将静态数据缓存下来(Chrome和FF情况下会缓存静态资源，不缓存数据；而IE什么都缓存)

> 尽管post比get更加安全，但是get和post都能被抓包，说明post也不是绝对安全的。   
> 但是在HTTP环境下，并不能保证安全性，所以要用HTTPS协议。

## 四次挥手

挥手就是终止TCP的连接。具体过程如下：

- 第一次挥手   
客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入**FIN_WAIT**的状态。
- 第二次挥手  
服务器端收到FIN之后，给客户端发送一个ACK,确认序号为收到序号+1。服务器端进入**CLOSE_WAIT**状态。
- 第三次挥手   
服务器端发送一个FIN,用来关闭服务器端到客户端的数据传送，服务器端进入**LAST_ACK**状态。
- 第四次挥手   
Client收到FIN后，Client进入**TIME_WAIT**状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入**CLOSED**状态，完成四次挥手。

#### Q：为什么要四次挥手？
如果客户端想要停止向服务端发送数据，首先要停止发送数据，并且通知对方，第二步是等待服务器的回复。

当然，服务器要向客户端停止发送数据，也得类似。   

四次挥手是因为 TCP 是全双工的，两端能同时向对方发送数据，如果不足四次的话无法确定双方都没有数据发送了。

# 重绘和回流

## 回流（reflow）
当render tree中的一部分或全部因为元素的规模、尺寸等布局因素改变而需要重新构建，就成为**回流**。

每个页面都至少有一次回流，就是在页面第一次加载的时候。

需要回流的情况：

    1、添加或者删除可见的DOM元素；
    2、元素位置改变；
    3、元素尺寸改变——边距、填充、边框、宽度和高度
    4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
    5、页面渲染初始化；
    6、浏览器窗口尺寸改变——resize事件发生时
## 重绘（repaint）

也许从repaint这个单词我们可以看出，重绘只是改变外观和风格，不影响布局（layout），比如`background-color` 属性。

值得注意的是，回流一定引起重绘，而重绘不一定引起回流。

### 性能优化
我们知道，重绘和回流都给浏览器造成压力。如果我们用JS不断、频繁地操作DOM,浏览器必将不堪重压。所以很多浏览器都会有一个优化机制：

> 浏览器会维护一个队列，将所有会引起重绘和回流的操作放入这个队列中，等队列中的**操作到了一定的数量或者时间间隔**，浏览器就会flush队列，进行一个批处理，将本来的多次回流重绘变成一次回流重绘。

虽然有了浏览器优化机制，但是，针对下面一些属性的更改，浏览器会提前flush队列，这样，优化就不起作用了：  

    1. offsetTop, offsetLeft, offsetWidth, offsetHeight
    2. scrollTop/Left/Width/Height
    3. clientTop/Left/Width/Height
    4. width,height
    5. 请求了getComputedStyle(), 或者 IE的 currentStyle
 
当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。

减少重绘和回流：   
1. 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）  
2. 让要操作的元素进行”离线处理”，处理完后一起更新  

    使用DocumentFragment进行缓存操作,引发一次回流和重绘；
    使用display:none技术，只引发两次回流和重绘；
    使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；

3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存    
4. 让元素脱离动画流，减少回流的Render Tree的规模

## Web端即时通讯技术

[https://blog.csdn.net/benhuo931115/article/details/52628725](https://blog.csdn.net/benhuo931115/article/details/52628725)

[http://www.52im.net/thread-338-1-1.html](http://www.52im.net/thread-338-1-1.html)

> 轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 
> 优点：后端程序编写比较容易。 
> 缺点：请求中有大半是无用，浪费带宽和服务器资源。 
> 实例：适于小型应用。
> 
> 
> 长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 
> 优点：在无消息的情况下不会频繁的请求，耗费资源小。 
> 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 
> 实例：WebQQ、Hi网页版、Facebook IM。
> 
> 长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。 
> 优点：消息即时到达，不发无用请求；管理起来也相对方便。 
> 缺点：服务器维护一个长连接会增加开销。 
> 实例：Gmail聊天

我们认识到基于web实现IM软件依然要走浏览器请求服务器的模式，这这种方式下，针对IM软件的开发需要解决如下三个问题：

#### 1 双全工通信：
即达到浏览器拉取（pull）服务器数据，服务器推送（push）数据到浏览器；
#### 2 低延迟：
即浏览器A发送给B的信息经过服务器要快速转发给B，同理B的信息也要快速交给A，实际上就是要求任何浏览器能够快速请求服务器的数据，服务器能够快速推送数据到浏览器；
#### 3 支持跨域：
通常客户端浏览器和服务器都是处于网络的不同位置，浏览器本身不允许通过脚本直接访问不同域名下的服务器，即使IP地址相同域名不同也不行，域名相同端口不同也不行，这方面主要是为了安全考虑。


### Ajax短轮询

传统的web应用要想与服务器交互，必须提交一个表单（form），服务器接收并处理传来的表单，然后返回全新的页面，因为前后两个页面的数据大部分都是相同的，这个过程传输了很多冗余的数据、浪费了带宽。于是Ajax技术便应运而生。

Ajax是Asynchronous JavaScript and XML的简称，由Jesse James Garrett 首先提出。这种技术开创性地允许浏览器脚本（JS）发送http请求。

这种浏览器端的小技术毕竟还是基于http协议，http协议要求的请求/响应的模式也是无法改变的，除非http协议本身有所改变。

---
### Comet(基于 HTTP长连接的“服务器推”技术)

Comet的实现主要有两种方式，基于Ajax的长轮询（long-polling）方式和基于 Iframe 及 htmlfile 的流（http streaming）方式。

#### 1 基于Ajax的长轮询（long-polling）方式

在上面的**Ajax短轮询**解决方案中，由于每次都要发送一个请求，服务端不管数据是否发生变化都发送数据，请求完成后连接关闭。这中间经过的很多通信是不必要的，于是又出现了长轮询（long-polling）方式。这种方式是**客户端发送一个请求到服务器，服务器查看客户端请求的数据是否发生了变化（是否有最新数据），如果发生变化则立即响应返回，否则保持这个连接并定期检查最新数据**，直到发生了数据更新或连接超时。同时客户端连接一旦断开，则再次发出请求，这样在相同时间内大大减少了客户端请求服务器的次数。

#### 2 基于 Iframe 及 htmlfile 的流（http streaming）方式
上面的long-polling技术为了保持客户端与服务端的长连接采取的是服务端阻塞（保持响应不返回），客户端轮询的方式，在Comet技术中（详细技术文章请参见《Comet技术详解：基于HTTP长连接的Web端实时通信技术》），还存在一种基于http-stream流的通信方式。

其原理是让客户端在一次请求中保持和服务端连接不断开，然后服务端源源不断传送数据给客户端，就好比数据流一样，并不是一次性将数据全部发给客户端。它与polling方式的区别在于整个通信过程客户端只发送一次请求，然后服务端保持与客户端的长连接，并利用这个连接在回送数据给客户端。

> 	1 基于XHR对象的streaming方式
> 	
> 	这种方式的思想是构造一个XHR对象，通过监听它的onreadystatechange事件，当它的readyState为3的时候，获取它的responseText然后进行处理，readyState为3表示数据传送中，整个通信过程还没有结束，所以它还在不断获取服务端发送过来的数据，直到readyState为4的时候才表示数据发送完毕，一次通信过程结束。在这个过程中，服务端传给客户端的数据是分多次以stream的形式发送给客户端，客户端也是通过stream形式来获取的，所以称作http-streaming数据流方式
> 
> 2基于iframe的数据流( **长连接**)

> 由于低版本的IE不允许在XHR的readyState为3的时候获取其responseText属性，为了达到在IE上使用这个技术，又出现了基于iframe的数据流通信方式。具体来讲，就是在浏览器中动态载入一个iframe,让它的src属性指向请求的服务器的URL，实际上就是向服务器发送了一个http请求，然后在浏览器端创建一个处理数据的函数，在服务端通过iframe与浏览器的长连接定时输出数据给客户端，但是这个返回的数据并不是一般的数据，而是一个类似于<script type=\"text/javascript\">parent.process('"+randomNum.toString()+"')</script>脚本执行的方式，浏览器接收到这个数据就会将它解析成js代码并找到页面上指定的函数去执行，实际上是服务端间接使用自己的数据间接调用了客户端的代码，达到实时更新客户端的目的。
> 
> 3基于htmlfile的数据流通信

> 又出现新问题了，在IE中，使用iframe请求服务端，服务端保持通信连接没有全部返回之前，浏览器title一直处于加载状态，并且底部也显示正在加载，这对于一个产品来讲用户体验是不好的，于是谷歌的天才们又想出了一中hack方式。就是在IE中，动态生成一个htmlfile对象，这个对象ActiveX形式的com组件，它实际上就是一个在内存中实现的HTML文档，通过将生成的iframe添加到这个内存中的HTMLfile中，并利用iframe的数据流通信方式达到上面的效果。同时由于HTMLfile对象并不是直接添加到页面上的，所以并没有造成浏览器显示正在加载的现象。代码如下。


---

### WebSocket


> 在上面的这些解决方案中，都是利用浏览器单向请求服务器或者服务器单向推送数据到浏览器这些技术组合在一起而形成的hack技术，在HTML5中，为了加强web的功能，提供了websocket技术，它不仅是一种web通信方式，也是一种应用层协议。它提供了浏览器和服务器之间原生的双全工跨域通信，通过浏览器和服务器之间建立websocket连接（实际上是TCP连接）,在同一时刻能够实现客户端到服务器和服务器到客户端的数据发送。关于该技术的原理，请参见：《WebSocket详解（一）：初步认识WebSocket技术》、《WebSocket详解（二）：技术原理、代码演示和应用案例》、《WebSocket详解（三）：深入WebSocket通信协议细节》，此处就不在赘述了，直接给出代码。在看代码之前，需要先了解websocket整个工作过程。
> 
> 首先是客户端new 一个websocket对象，该对象会发送一个http请求到服务端，服务端发现这是个webscoket请求，会同意协议转换，发送回客户端一个101状态码的response，以上过程称之为一次握手，经过这次握手之后，客户端就和服务端建立了一条TCP连接，在该连接上，服务端和客户端就可以进行双向通信了。这时的双向通信在应用层走的就是ws或者wss协议了，和http就没有关系了。所谓的ws协议，就是要求客户端和服务端遵循某种格式发送数据报文（帧），然后对方才能够理解。


###  SSE

> SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的HTML5技术。与由客户端每隔几秒从服务端轮询拉取新数据相比，这是一种更优的解决方案。
> 
> 与WebSocket相比，它也能从服务端向客户端推送数据。那如何决定你是用SSE还是WebSocket呢？概括来说，WebSocket能做的，SSE也能做，反之亦然，但在完成某些任务方面，它们各有千秋。
> 
> WebSocket是一种更为复杂的服务端实现技术，但它是真正的双向传输技术，既能从服务端向客户端推送数据，也能从客户端向服务端推送数据。
> 
> WebSocket和SSE的浏览器支持率差不多，大多数主流桌面浏览器两者都支持。在Android 4.3以及更早的版本中，系统默认浏览器两者都不支持，Firefox和Chrome则完全支持；Android 4.4中，系统默认浏览器两者都支持；Safari从5.0开始支持SSE（iOS系统从4.0开始），但直到6.0才正确地支持WebSocket（6.0之前的Safari所实现的WebSocket协议存在安全问题，所以一些主流浏览器已经禁用了基于这个协议的实现）。
> 
> 与WebSocket相比，SSE有一些显著的优势。个人认为它最大的优势就是便利：不需要添加任何新组件，用任何你习惯的后端语言和框架就能继续使用。你不用为新建虚拟机、弄一个新的IP或新的端口号而劳神，就像在现有网站中新增一个页面那样简单。我喜欢把这称为既存基础设施优势。
> 
> SSE的第二个优势是服务端的简洁。相对而言，WebSocket则很复杂，不借助辅助类库基本搞不定

## 浏览器缓存
浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。

### 浏览器缓存的优点有：


- 减少了冗余的数据传输，节省了网费

- 减少了服务器的负担，大大提升了网站的性能

- 加快了客户端加载网页的速度

### 浏览器缓存的分类
**浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓**存。

浏览器在第一次请求发生后，再次请求时：


> 浏览器会先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；

> 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容

### 强缓存
> 强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。


**从名字就可以看出，强缓存不与服务器交互，而协商缓存则需要与服务器交互**

#### Expires

该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。

#### Cache-Control
Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：

no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。

no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。

public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。

### 协商缓存
> 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。

### Last-Modify/If-Modify-Since

浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。

当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。

如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。

### ETag/If-None-Match

与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。

与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。

### 为什么要有Etag

你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；

某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；

某些服务器不能精确的得到文件的最后修改时间。

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

### 强缓存与协商缓存的区别可以用下表来表示：

缓存类型	获取资源形式	状态码	发送请求到服务器
强缓存	从缓存取	200（from cache）	否，直接从缓存取
协商缓存	从缓存取	304（Not Modified）	否，通过服务器来告知缓存是否可用

### 用户行为对缓存的影响

用户操作				Expires/Cache-Control	Last-Modied/Etag
地址栏回车			有效							有效
页面链接跳转			有效							有效
新开窗口				有效							有效
前进回退				有效							有效
F5刷新				无效							有效
Ctrl+F5强制刷新		无效							无效
