## CSS盒模型
### 一 css盒子模型概念
CSS css盒子模型 又称框模型 (Box Model) ，包含了 元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素
### 二 css 外边距合并（叠加）
两个上下方向相邻的元素框垂直相遇时，外边距会合并，合并后的外边距的高度等于两个发生合并的外边距中较高的那个边距值

需要注意的是：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并
###三、box-sizing属性介绍
box-sizing属性是用户界面属性里的一种，之所以介绍它，是因为这个属性跟盒子模型有关，而且在css reset中有可能会用到它。

box-sizing : content-box|border-box|inherit;

(1) content-box ,默认值，可以使设置的宽度和高度值应用到元素的内容框。盒子的width只包含内容。

　　即总宽度=margin+border+padding+width

(2) border-box , 设置的width值其实是除margin外的border+padding+element的总宽度。盒子的width包含border+padding+内容

　　　　即总宽度=margin+width

很多CSS框架，都会对盒子模型的计算方法进行简化。

(3) inherit , 规定应从父元素继承 box-sizing 属性的值
### 关于border-box的使用(应用场景)：  
> 1 一个box宽度为100%，又想要两边有内间距，这时候用border-box就比较好  
2 全局设置 border-box 很好，首先它符合直觉，其次它可以省去一次又一次的加加减减，它还有一个关键作用——让有边框的盒子正常使用百分比宽度。  
### 四、实际开发中遇到的和框模型相关的应用及小问题。  
#### 1 margin越界（第一个子元素的margin-top和最后一个子元素的margin-bottom的越界问题）

以第一个子元素的margin-top 为例：

当父元素没有边框border时，设置第一个子元素的margin-top值的时候，会出现margin-top值加在父元素上的现象，解决方法有四个：

- 给父元素加边框border （副作用）

- 给父元素设置padding值  （副作用）

- 父元素添加 overflow：hidden （副作用）

- 父元素加前置内容生成。（推荐）

以第四种方法为例：  
```
.parent {
     width : 500px;
     height : 500px;
     background-color : red;       
}
.parent : before {
     content : " ";
     display : table;
}

.child {
     width : 200px;
     height : 200px;
     background-color : green;
     margin-top : 50px;
}

<div class="parent">
    <div class="child"></div> 
</div>

```

#### 2 浏览器间的盒子模型。

（1）ul标签在Mozilla中默认是有padding值的，而在IE中只有margin有值。

（2）标准盒子模型与IE模型之间的差异：

标准的盒子模型就是上述介绍的那种，而IE模型更像是 box-sizing : border-box; 和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border 和 pading。
解决办法就是：在html模板中加doctype声明。

#### 3 用盒子模型画三角形

    <!DOCTYPE html>
    <html>
      <head>
    <style>
    .triangle {
    width : 0;
    height: 0;
    border : 100px solid transparent;
    border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角*/
    }
    </style>
      </head>
      <body>
    <div class="triangle"></div>
      </body>
    </html>


## FLEX布局  

flex（ flexible box：弹性布局盒模型）,是2009年w3c提出的一种可以简洁、快速弹性布局的属性。**主要思想是给予容器控制内部元素高度和宽度的能力。**
采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。

容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。
主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；  
交叉轴的开始位置叫做cross start，结束位置叫做cross end。
项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。


**首先要有个容器，并设置display:flex;display:-webkit-flex;该容器有以下六个属性：**
	
    flex-direction (元素排列方向)  
    	row, row-reverse, column, column-reverse  
    flex-wrap (换行)  
    	nowrap, wrap, wrap-reverse  
    flex-flow (以上两者的简写)  
    	flex-direction || flex-wrap  
    justify-content (水平对齐方式)  
    	flex-start, flex-end, center, space-between, space-around  
    align-items (垂直对齐方式)  
    	stretch, flex-start, flex-end, center, baseline  
    align-content (多行垂直对齐方式)  
    	stretch, flex-start, flex-end, center, space-between, space-around  

整体的layout用grid，某个section用flex
Flex 和 Grid 并不是互斥的技术，相反，它们是互补的。  
Flex 一般用来做 Page Components 的局部布局，而且一般只做一维的布局，比如导航栏。  
Grid 则一般用来做二维平面的布局，通常用于整个页面的规划。这也是这两个技术发明的初衷，它们相辅相成，并行不悖。

## 上下左右垂直居中

**【思路一】： 行高line-height实现单行文本垂直居中**

　　行内流传着一种说法，单行文本垂直居中要将高度和行高设置成相同的值，但高度其实没必要设置。实际上，文本本身就在一行中居中显示。在不设置高度的情况下，行高撑开高度

**【思路二】：设置vertical-align:middle实现垂直居中**

【1】设置父元素的display为table-cell

　　通过为table-cell元素设置vertical-align:middle，可使其子元素均实现垂直居中。这和表格里单元格的垂直居中是类似的

　　[注意]若要IE7-浏览器支持，则可以将其改为<table>表格结构

　　[注意]设置为table-cell的div不能使用浮动或绝对定位，因为浮动或绝对定位会使元素具有块级元素特性，从而丧失了table-cell元素具有的垂直对齐的功能。若需要浮动或绝对定位处理，则需要外面再套一层div

    <style>
    .parent{
      display: table-cell;
      vertical-align: middle;
    }
    </style>
    <div class="parent" style="height: 100px;">
    <div class="child" >我是有点长的有点长的有点长的有点长的测试文字</div>   
    </div>  

**若子元素是图片，通过设置父元素的行高来代替高度，且设置父元素的font-size为0**

vertical-align:middle的解释是元素的中垂点与父元素的基线加1/2父元素中字母X的高度对齐。  
由于字符X在em框中并不是垂直居中的，且各个字体的字符X的高低位置不一致。  
所以，当字体大小较大时，这种差异就更明显。  
当font-size为0时，相当于把字符X的字体大小设置为0，于是可以实现完全的垂直居中

    <style>
    .parent{
      line-height: 100px;
      font-size: 0;
    }
    .child{
      vertical-align: middle;
    }
    </style>

    <div class="parent" style="background-color: lightgray;width:200px;">
    <img class="child" src="http://sandbox.runjs.cn/uploads/rs/26/ddzmgynp/img1.gif" width="50%" alt="test">  
    </div>

**【思路三】：通过绝对定位实现垂直居中**

【1】配合translate()位移函数  
translate函数的百分比是相对于自身高度的，所以top:50%配合translateY(-50%)可实现居中效果  

[注意]IE9-浏览器不支持  

[注意]若子元素的高度已知，translate()函数也可替换为margin-top: 负的高度值

    .parent{
      position:relative;
    }
    .child{
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
    }
    
    <div class="parent">
      <div class="child" >测试文字</div>
    </div>  


**【思路四】：使用弹性盒模型flex实现垂直居中**

【1】在伸缩容器上设置侧轴对齐方式align-items: center

    <style>
    .parent{
      display: flex;
      align-items: center;
    }
    </style>
    <div class="parent" style="height: 100px;">
    <div class="child">测试文字</div>   
    </div>
【2】在伸缩项目上设置margin: auto 0
    
    .parent{
      display: flex;
    }
    .child{
      margin: auto 0;
    }

    <div class="parent" style="height: 100px;">
    <div class="child" >测试文字</div>   
    </div>

**【思路五】: 使用栅格布局grid实现垂直居中**  
【1】在网格容器上设置align-items或align-content

【2】在网格项目中设置align-self或者margin: auto 0

    .parent{
      display:grid;
    } 
    .child{
      align-self:center;
     /*margin: auto 0;*/
    }
    
    <div class="parent" style="background-color: gray; height: 100px;">
    <div class="child" style="background-color: lightblue;">测试文字</div>   
    </div>
----
## 原型链，对象，构造函数之间的一些联系

    function test(){

	}    
    console.log(test.prototype.constructor === test) // true
> 　如上，当我们创建一个函数，系统就会为这个函数自动分配一个prototype指针，指向它的原型对象。  
> 　并且可以发现，这个原型对象包含两个部分（constructor 和 __proto__）其中constructor指向函数自身。（这里形成了一个小闭环）

	function test(){

	}
	var mytest = new test;   
	console.log(mytest.__proto__ === test.prototype) // true

	function test(){

	}
	var mytest = new test; 
	console.log(mytest.__proto__.constructor === test) // true


> 如上,当我们将该函数作为模版创建实例（new方法）的时候，我们发现创建出的实例是一个与构造函数同名的object，这个object是独立的，他只包含了一个__proto__指针（实例没有prototype，强行访问则会输出undefined），这个指针指向上面提到的构造函数的prototype原型对象。  
> 
> 这时候我们发现三者形成了一个大"闭环"。之所以加上引号，因为构造函数和实例之间无法直接访问，需要通过__proto__指针间接读取。

 这个"大闭环"画出来就是下面这个样子啦：


### (2) prototype是啥，__proto__又是啥，他们之间啥关系？
	
在上一个问题中，我们用到了实例对象的__proto__指针，实际上在JavaScript中大部分类型的值都拥有__proto__属性，例如：

    console.log('str'.__proto__)
    String {length: 0, encodeHTML: ƒ, constructor: ƒ, charAt: ƒ, charCodeAt: ƒ, …}
    
    console.log(NaN.__proto__)
    Number {constructor: ƒ, toExponential: ƒ, toFixed: ƒ, toPrecision: ƒ, toString: ƒ, …}
    
    console.log(true.__proto__)
    Boolean {[[PrimitiveValue]]: false, constructor: ƒ, toString: ƒ, valueOf: ƒ}

当然object和function对象也有：

    function test(){} 
    console.log(test.__proto__);
    ƒ () { [native code] }

不过也有不存在__proto___属性的类型，比如：  
**undefined和null**

然而。只有function对象才有prototype属性，其他任何类型的值都没有。即使是使用new方法从function构造出的实例对象也没有prototype属性。

###（3）如果改变一个 constructor 的 prototype，他的实例会发生什么改变？
   
我们来做一个尝试:  

    function OmakeNewCar(){}
    function QmakeNewCar(){}
    var car = new OmakeNewCar;
    
    OmakeNewCar.prototype = function QmakeNewCar(){};
    var truck = new QmakeNewCar;
    
    console.log(truck);
    
    console.log(car);
    VM236:8 QmakeNewCar {}__proto__: constructor: ƒ QmakeNewCar()__proto__: Object
    VM236:10 OmakeNewCar {}__proto__: constructor: ƒ OmakeNewCar()__proto__: Object
    

我们可以发现，改变了prototype之后创建的实例指向了新的prototype对象，而之前的依然指向老的prototype对象。