
HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：
## HTTP状态码分类
分类	分类描述

* 1**	信息，服务器收到请求，需要请求者继续执行操作
* 2**	成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误



## 输入url到加载完成发生了什么

一般会经历以下过程：

1.在浏览器中输入url。  
2.浏览器先查看**浏览器缓存--系统缓存--路由器缓存**，如果缓存中存在页面内容，就会直接在屏幕中显示。  
3.在发送http请求前，浏览器开启一个线程来解析域名(**[DNS解析]**，获取相应的IP地址。   
4.浏览器向服务器发起TCP连接，与浏览器通过**TCP三次握手**建立连接；	   
5.握手成功后，浏览器向服务器发送**HTTP请求**，请求数据包。  
6.服务器处理收到的请求，将数据返回给浏览器。   
7.浏览器收到**HTTP响应**。   
8.接下来就是**[页面渲染]**的内容了。

## 三次握手

第一次握手：客户端向服务器发送**SYN**报文，传达信息 “你好，我想建立连接”，客户端进入SYN_SEND状态。                         
第二次握手：服务器返回**SYN+ACK**报文，传达信息 “好的，可以建立连接”，服务器端进入SYN_REC状态。                           
第三次握手：客户端回传 **ACK**报文,传达信息“好的，知道了，那我们连接”，然后就建立连接了。此时客户端和服务器端都进入ESTABLISHED状态。                     

三次握手的机制是为了保证信息传输的可靠性，如果其中某个握手失败了，这个过程将会重复。 
 
- 如果采用两次握手：   
如果发送ACK报文的客户端不想连接了，也没有反馈，而服务器端则一直等待，浪费了时间。
- 如果采用四次握手：    
从结果而言是可以的，但是性能大大受影响，三次是个折中的方案，节省了连接的时间。


## 页面渲染原理

主流的Webkit内核浏览器（Safiri）和Gecko内核浏览器（FireFox）在渲染引擎的具体步骤上有些不同，但是大致的原理如下图：
  
![](http://i.imgur.com/cI1G3m5.jpg)

1. 浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。

2. 浏览器把CSS样式解析成样式解析成样式结构体CSSDOM树，解析过程中去掉浏览器不能识别的样式，比如IE浏览器去掉-moz开头的样式，而FF浏览器去掉_开头的样式等。

3. DOM树和CSSDOM树组合构建渲染树（render tree），此时的render tree和DOM相似，但事实上有很大的区别。render tree能识别样式。render tree里面的每一个节点都有自己的样式，因此，像<head>标签这些不用于渲染的节点，不会被包含于render tree中。render tree中每一个节点都可以称作盒子（Box）。   
值得注意的是，`display: none；` 和 `visible： hidden；`虽然很像，但是前者不会被包含在render tree中，因为它是不占空间而且不可见的，后者虽然不可见，但是占用空间，会影响布局（layout），所以包含在数中。

4. 一旦render tree构建完毕，浏览器就可以根据render tree来绘制页面了。

## post和get
区别：

- post更安全  
因为post的请求数据不会作为url的一部分，不会被缓存、保存在服务器日志、浏览器的浏览记录中。
- post发送的数据量更大  
get有url长度的限制，不能大于2kb。
- post能发送更多的数据类型  
get只能发送ASCII字符
- post比get要慢  
	- post方法在正式接收数据之前会将请求投发送给服务器确认，然后才发送数据，这个确认过程花费较长的时间。
	- get方法会将静态数据缓存下来(Chrome和FF情况下会缓存静态资源，不缓存数据；而IE什么都缓存)

> 尽管post比get更加安全，但是get和post都能被抓包，说明post也不是绝对安全的。   
> 但是在HTTP环境下，并不能保证安全性，所以要用HTTPS协议。

## 四次挥手

挥手就是终止TCP的连接。具体过程如下：

- 第一次挥手   
客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入**FIN_WAIT**的状态。
- 第二次挥手  
服务器端收到FIN之后，给客户端发送一个ACK,确认序号为收到序号+1。服务器端进入**CLOSE_WAIT**状态。
- 第三次挥手   
服务器端发送一个FIN,用来关闭服务器端到客户端的数据传送，服务器端进入**LAST_ACK**状态。
- 第四次挥手   
Client收到FIN后，Client进入**TIME_WAIT**状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入**CLOSED**状态，完成四次挥手。

#### Q：为什么要四次挥手？
如果客户端想要停止向服务端发送数据，首先要停止发送数据，并且通知对方，第二步是等待服务器的回复。

当然，服务器要向客户端停止发送数据，也得类似。   

四次挥手是因为 TCP 是全双工的，两端能同时向对方发送数据，如果不足四次的话无法确定双方都没有数据发送了。

# 重绘和回流

## 回流（reflow）
当render tree中的一部分或全部因为元素的规模、尺寸等布局因素改变而需要重新构建，就成为**回流**。

每个页面都至少有一次回流，就是在页面第一次加载的时候。

需要回流的情况：

    1、添加或者删除可见的DOM元素；
    2、元素位置改变；
    3、元素尺寸改变——边距、填充、边框、宽度和高度
    4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
    5、页面渲染初始化；
    6、浏览器窗口尺寸改变——resize事件发生时
## 重绘（repaint）

也许从repaint这个单词我们可以看出，重绘只是改变外观和风格，不影响布局（layout），比如`background-color` 属性。

值得注意的是，回流一定引起重绘，而重绘不一定引起回流。

### 性能优化
我们知道，重绘和回流都给浏览器造成压力。如果我们用JS不断、频繁地操作DOM,浏览器必将不堪重压。所以很多浏览器都会有一个优化机制：

> 浏览器会维护一个队列，将所有会引起重绘和回流的操作放入这个队列中，等队列中的**操作到了一定的数量或者时间间隔**，浏览器就会flush队列，进行一个批处理，将本来的多次回流重绘变成一次回流重绘。

虽然有了浏览器优化机制，但是，针对下面一些属性的更改，浏览器会提前flush队列，这样，优化就不起作用了：  

    1. offsetTop, offsetLeft, offsetWidth, offsetHeight
    2. scrollTop/Left/Width/Height
    3. clientTop/Left/Width/Height
    4. width,height
    5. 请求了getComputedStyle(), 或者 IE的 currentStyle
 
当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。

减少重绘和回流：   
1. 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）  
2. 让要操作的元素进行”离线处理”，处理完后一起更新  

    使用DocumentFragment进行缓存操作,引发一次回流和重绘；
    使用display:none技术，只引发两次回流和重绘；
    使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；

3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存    
4. 让元素脱离动画流，减少回流的Render Tree的规模
